File Format Submodules
======================

For each supported format there is a submodule with the prefix
``opg_formatname``. These submodules are where you will find each format's
read/write/write2hdf methods.


Native HDF5
-------------------------
``opg_hdf5.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This submodule contains the ``OpgHdf5`` class which inherits its properties
from a dictionary object. Its main functionality is the method ``open_file``
that will read an HDF5 file into a dictionary. Then, we can use this to write
to another format using that formats write capabilities and the information
stored in the HDF5 file's dictionary. This is the functinality is used in the
script ``opac_table2hdf`` in the :ref:`clts`.


.. _opg_ionmix:

IONMIX (.cn4)
-------------------------

``opg_ionmix.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This is the main submodule for the IONMIX format that *FLASH* uses. It contains
two main classes. The ``OpacIonmix`` class is used to read in an IONMIX file
and translate its information into a dictionary object. It takes two required
arguments, the filename (``fn``) and the mass per ion (``mpi``). It
also takes 3 optional boolean arguments, which all default to false: 
two-temperature data (``twot``), manual temp/dens points
(``man``), and electron entropy data (``hassele``). If you receive a ``ValueError:
invalid literal for int() with base 10`` error, setting ``man=True`` will fix this.

Since *FLASH* uses IONMIX
files, this submodule also contains a special ``writeIonmixFile`` class.
It takes five required arguments:

#. filename (``fn``)
#. tuple of atomic numbers (``zvals``)
#. tuple of material fractions (``fracs``)
#. array of number densities (``numdens``)
#. array of temperatures (``temps``)

It also takes a large amount of optional keyword arguments that correspond to
the IONMIX format's capabilities. A * indicates that this data point is ignored
by *FLASH* per the user manual. A ** indicates that this data point is only
used for tabulated EoS in *FLASH*:

#. average ionization (``zbar``)**
#. temperature derivative of average ionization (``dzdt``)*
#. ion pressure (``pion``)**
#. electron pressure (``pele``)**
#. temperature derivative of ion pressure (``dpidt``)*
#. temperature derivative of electron pressure (``dpedt``)*
#. ion specific internal energy (``eion``)**
#. electron specific internal energy (``eele``)**
#. ion heat capacity at constant volume (``cvion``)*
#. electron heat capacity at constant volume(``cvele``)*
#. number derivative of ion energy (``deidn``)*
#. number derivative of electron energy (``deedn``)*
#. number of energy groups (``ngroups``)
#. energy group boundaries (``opac_bounds``)
#. Rosseland opacities (``rosseland``)**
#. Planck absorption opacity (``planck_absorb``)**
#. Planck emission opacity (``planck_emiss``)**

This is the functionality that the script ``opac_hdf2table`` in
:ref:`clts` uses for the IONMIX format. It opens an HDF5 file
into a dictionary and uses each key to assign a value to each of the
``writeIonmixFile``'s arguments.


``adapt.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This class provides filtering capabilities for the EoS temperature and
density grids. For instance, SESAME tables may have some additionnal points
in the ion EoS table compared to the elecron EoS table. Since *FLASH* requires
the same density and temperature grid for all species, the simplest solution is
to remove those extra points.

Parameters:

#. eos_data: [dict] dictionary contraining the EoS data.
#. intersect: [list] the resulting temperature [eV] and density [g/cm⁻³]
   grids will be computed as an intersection of grids of all the
   species given in this list. The default is ``['ele', 'ioncc']``.
#. filter_dens, filter_temps: [function] a function that takes a grid
   and returns a mask of points we don't wont to keep.
   The default is ``(lamdba x: x>0.)``, i.e. don't remove anything.
#. thresh: zero threshold on folowing keys

Returns ``out``, a dictionary with the same keys a eos_data.

Code example::

    eos_sesame = opp.OpgSesame("../sesame/xsesame_ascii", opp.OpgSesame.SINGLE,verbose=False)
    eos_data  = eos_sesame.data[3720]  # Aluminum
    eos_data_filtered = EosMergeGrids(eos_data,
                        intersect=['ele', 'ioncc'],   # merge electron and ion grids
                        filter_temps=lamda x: x>1.) # remove temperatures below 1eV


MULTI (.opp, .opr, .eps)
-------------------------

``eos_multi.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

**Not sure on what this does compared to ``opg_multi``.**


``opg_multi.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This submodule is used to either parse or write MULTIv5 tables. Its class
``OpgMulti`` has two ways to read data. The first, and more general way, is
passing it an unpacked dictionary of EoS and opacity data. This is how the
script ``opac_hdf2table`` uses the class in :ref:`clts`. It first
opens up an HDF5 file into a dictionary object using ``OpgHdf5``. Then, it
instantiates an ``OpgMulti`` object using the unpacked dictionary object from
the HDF5 file. Here is an example that reads in an HDF5 file into an
``OpgMulti`` object::

    op_hdf = OpgHdf5.open_file('base_dir', 'base_filename')
    op_multi = OpgMulti(**op_hdf)

The second way to read data in ``OpgMulti`` comes from the ``open_file`` class
method. Unlike the last process, this will only read data from a MULTIv5 file.
It takes two parameters: the ``folder`` and ``base_name`` of the designated
file. It also has an optional ``verbose`` keyword argument.

This submodule also includes two different write functionalities. One,
``write``, will take the data currently contained in an ``OpgMulti`` instance
and write it to a MULTIv5 file format. It takes one parameter, ``prefix``,
which specifies the common prefix of the files that ``write`` will create. From
the example above, after reading in the dictionary of data from the HDF5 file,
one must call::

    op_multi.write('multi_')

to write data files containing multigroup opacities specified by the 'multi\_'
prefix.

The second write functionality comes from the ``write2hdf`` method. This, like
``write``, relies on data already parsed into an ``OpgMulti`` instance.
However, ``write2hdf`` will write to an HDF5 file rather than MULTIv5. This is
particularly useful in converting between file formats using HDF5 as a
middleman. This method takes one parameter, ``filename``, to specify the output
file's name. It also has three optional keyword arguments: ''Znum'', ''Anum'',
and ''Xnum''. The atomic number, ''Znum'', and relative fractions, ''Xnum'',
must be given if they are not already parsed into an instance of ``OpgMulti``.
If they are not, ``write2hdf`` will raise a ``ValueError``.


SESAME ASCII (.ses)
-------------------------
``opg_sesame.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This submodule is responsible for loading all SESAME formatted data files. The
main class is ``OpgSesame``, which reads a SESAME file into a dictionary object as it
is instantiated. It takes two parameters: ``filename`` and ``precision`` of the
input file. Precision is either single or double and can be referenced with
``OpgSesame.SINGLE`` (``1``) or ``OpgSesame.DOUBLE`` (``2``). It also has an
optional ``verbose`` keyword argument.

Upon instantiating ``OpgSes_Instance``, it creates a dictionary
``OpgSes_Instance.data[]``. The ``data`` dictionary contains keys corresponding
to the table IDs contained in the SESAME file. So, the EoS data must be
accessed by calling ``OpgSes_Instance.data[table_id]``. This dictionary will
hold the EoS data for the table referenced by ``table_id``.

**Note:** there are currently no handling functions for 500 series
entries in the SESAME tables.


TOPS
-------------------------

``opg_tops.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

This completely doesn't match up with the files generated online.


INFERNO
-------------------------

``opg_inferno.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

Can't find any files online.


PROPACEOS ASCII (.prp)
-------------------------

``opg_propaceos.py``
^^^^^^^^^^^^^^^^^^^^^^^^^

Not publicly distributed.
